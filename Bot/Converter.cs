// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using UserIDsConverter;
//
//    var userIDs = UserIDs.FromJson(jsonString);

namespace UserIDsConverter
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using J = Newtonsoft.Json.JsonPropertyAttribute;
    using R = Newtonsoft.Json.Required;
    using N = Newtonsoft.Json.NullValueHandling;

    public partial class UserIdClass
    {
        [J("id")] public long Id { get; set; }
    }

    public partial struct UserIdUnion
    {
        public bool? Bool;
        public List<UserIdClass> UserIdClassArray;

        public static implicit operator UserIdUnion(bool Bool) => new UserIdUnion { Bool = Bool };
        public static implicit operator UserIdUnion(List<UserIdClass> UserIdClassArray) => new UserIdUnion { UserIdClassArray = UserIdClassArray };
    }

    public class UserIDs
    {
        public static List<UserIdUnion> FromJson(string json) => JsonConvert.DeserializeObject<List<UserIdUnion>>(json, Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this List<UserIdUnion> self) => JsonConvert.SerializeObject(self, Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                UserIdUnionConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class UserIdUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(UserIdUnion) || t == typeof(UserIdUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new UserIdUnion { Bool = boolValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<UserIdClass>>(reader);
                    return new UserIdUnion { UserIdClassArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type UserIdUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (UserIdUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.UserIdClassArray != null)
            {
                serializer.Serialize(writer, value.UserIdClassArray);
                return;
            }
            throw new Exception("Cannot marshal type UserIdUnion");
        }

        public static readonly UserIdUnionConverter Singleton = new UserIdUnionConverter();
    }
}

// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using UsernameConverter;
//
//    var username = Username.FromJson(jsonString);

namespace UsernameConverter
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using J = Newtonsoft.Json.JsonPropertyAttribute;
    using R = Newtonsoft.Json.Required;
    using N = Newtonsoft.Json.NullValueHandling;

    public partial class UsernameClass
    {
        [J("username")] public string Username { get; set; }
    }

    public partial struct UsernameUnion
    {
        public bool? Bool;
        public List<UsernameClass> UsernameClassArray;

        public static implicit operator UsernameUnion(bool Bool) => new UsernameUnion { Bool = Bool };
        public static implicit operator UsernameUnion(List<UsernameClass> UsernameClassArray) => new UsernameUnion { UsernameClassArray = UsernameClassArray };
    }

    public class Username
    {
        public static List<UsernameUnion> FromJson(string json) => JsonConvert.DeserializeObject<List<UsernameUnion>>(json, UsernameConverter.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this List<UsernameUnion> self) => JsonConvert.SerializeObject(self, UsernameConverter.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                UsernameUnionConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class UsernameUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(UsernameUnion) || t == typeof(UsernameUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new UsernameUnion { Bool = boolValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<UsernameClass>>(reader);
                    return new UsernameUnion { UsernameClassArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type UsernameUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (UsernameUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.UsernameClassArray != null)
            {
                serializer.Serialize(writer, value.UsernameClassArray);
                return;
            }
            throw new Exception("Cannot marshal type UsernameUnion");
        }

        public static readonly UsernameUnionConverter Singleton = new UsernameUnionConverter();
    }
}

// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using AccessTokenConverter;
//
//    var accessToken = AccessToken.FromJson(jsonString);

namespace AccessTokenConverter
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using J = Newtonsoft.Json.JsonPropertyAttribute;
    using R = Newtonsoft.Json.Required;
    using N = Newtonsoft.Json.NullValueHandling;

    public partial class AccessTokenClass
    {
        [J("access_token")] public string AccessToken { get; set; }
    }

    public partial struct AccessTokenUnion
    {
        public List<AccessTokenClass> AccessTokenClassArray;
        public bool? Bool;

        public static implicit operator AccessTokenUnion(List<AccessTokenClass> AccessTokenClassArray) => new AccessTokenUnion { AccessTokenClassArray = AccessTokenClassArray };
        public static implicit operator AccessTokenUnion(bool Bool) => new AccessTokenUnion { Bool = Bool };
    }

    public class AccessToken
    {
        public static List<AccessTokenUnion> FromJson(string json) => JsonConvert.DeserializeObject<List<AccessTokenUnion>>(json, AccessTokenConverter.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this List<AccessTokenUnion> self) => JsonConvert.SerializeObject(self, AccessTokenConverter.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                AccessTokenUnionConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class AccessTokenUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AccessTokenUnion) || t == typeof(AccessTokenUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new AccessTokenUnion { Bool = boolValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<AccessTokenClass>>(reader);
                    return new AccessTokenUnion { AccessTokenClassArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type AccessTokenUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AccessTokenUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.AccessTokenClassArray != null)
            {
                serializer.Serialize(writer, value.AccessTokenClassArray);
                return;
            }
            throw new Exception("Cannot marshal type AccessTokenUnion");
        }

        public static readonly AccessTokenUnionConverter Singleton = new AccessTokenUnionConverter();
    }
}

// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using RefreshTokenConverter;
//
//    var refreshToken = RefreshToken.FromJson(jsonString);

namespace RefreshTokenConverter
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using J = Newtonsoft.Json.JsonPropertyAttribute;
    using R = Newtonsoft.Json.Required;
    using N = Newtonsoft.Json.NullValueHandling;

    public partial class RefreshTokenClass
    {
        [J("refresh_token")] public string RefreshToken { get; set; }
    }

    public partial struct RefreshTokenUnion
    {
        public bool? Bool;
        public List<RefreshTokenClass> RefreshTokenClassArray;

        public static implicit operator RefreshTokenUnion(bool Bool) => new RefreshTokenUnion { Bool = Bool };
        public static implicit operator RefreshTokenUnion(List<RefreshTokenClass> RefreshTokenClassArray) => new RefreshTokenUnion { RefreshTokenClassArray = RefreshTokenClassArray };
    }

    public class RefreshToken
    {
        public static List<RefreshTokenUnion> FromJson(string json) => JsonConvert.DeserializeObject<List<RefreshTokenUnion>>(json, RefreshTokenConverter.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this List<RefreshTokenUnion> self) => JsonConvert.SerializeObject(self, RefreshTokenConverter.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                RefreshTokenUnionConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class RefreshTokenUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RefreshTokenUnion) || t == typeof(RefreshTokenUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new RefreshTokenUnion { Bool = boolValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<RefreshTokenClass>>(reader);
                    return new RefreshTokenUnion { RefreshTokenClassArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type RefreshTokenUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (RefreshTokenUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.RefreshTokenClassArray != null)
            {
                serializer.Serialize(writer, value.RefreshTokenClassArray);
                return;
            }
            throw new Exception("Cannot marshal type RefreshTokenUnion");
        }

        public static readonly RefreshTokenUnionConverter Singleton = new RefreshTokenUnionConverter();
    }
}

// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using UpdateOAuthTokenConverter;
//
//    var updateOAuthToken = UpdateOAuthToken.FromJson(jsonString);

namespace UpdateOAuthTokenConverter
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using J = Newtonsoft.Json.JsonPropertyAttribute;
    using R = Newtonsoft.Json.Required;
    using N = Newtonsoft.Json.NullValueHandling;

    public partial struct UpdateOAuthTokenElement
    {
        public object[] AnythingArray;
        public bool? Bool;

        public static implicit operator UpdateOAuthTokenElement(object[] AnythingArray) => new UpdateOAuthTokenElement { AnythingArray = AnythingArray };
        public static implicit operator UpdateOAuthTokenElement(bool Bool) => new UpdateOAuthTokenElement { Bool = Bool };
    }

    public class UpdateOAuthToken
    {
        public static UpdateOAuthTokenElement[] FromJson(string json) => JsonConvert.DeserializeObject<UpdateOAuthTokenElement[]>(json, UpdateOAuthTokenConverter.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this UpdateOAuthTokenElement[] self) => JsonConvert.SerializeObject(self, UpdateOAuthTokenConverter.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                UpdateOAuthTokenElementConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class UpdateOAuthTokenElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(UpdateOAuthTokenElement) || t == typeof(UpdateOAuthTokenElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new UpdateOAuthTokenElement { Bool = boolValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<object[]>(reader);
                    return new UpdateOAuthTokenElement { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type UpdateOAuthTokenElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (UpdateOAuthTokenElement)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            throw new Exception("Cannot marshal type UpdateOAuthTokenElement");
        }

        public static readonly UpdateOAuthTokenElementConverter Singleton = new UpdateOAuthTokenElementConverter();
    }
}


// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using FAQConverter;
//
//    var faq = Faq.FromJson(jsonString);

namespace FAQConverter
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using J = Newtonsoft.Json.JsonPropertyAttribute;
    using R = Newtonsoft.Json.Required;
    using N = Newtonsoft.Json.NullValueHandling;

    public partial class FaqClass
    {
        [J("question")] public string Question { get; set; }
        [J("id")] public long Id { get; set; }
    }

    public partial struct FaqUnion
    {
        public bool? Bool;
        public List<FaqClass> FaqClassArray;

        public static implicit operator FaqUnion(bool Bool) => new FaqUnion { Bool = Bool };
        public static implicit operator FaqUnion(List<FaqClass> FaqClassArray) => new FaqUnion { FaqClassArray = FaqClassArray };
    }

    public class Faq
    {
        public static List<FaqUnion> FromJson(string json) => JsonConvert.DeserializeObject<List<FaqUnion>>(json, FAQConverter.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this List<FaqUnion> self) => JsonConvert.SerializeObject(self, FAQConverter.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                FaqUnionConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class FaqUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FaqUnion) || t == typeof(FaqUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new FaqUnion { Bool = boolValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<FaqClass>>(reader);
                    return new FaqUnion { FaqClassArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type FaqUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FaqUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.FaqClassArray != null)
            {
                serializer.Serialize(writer, value.FaqClassArray);
                return;
            }
            throw new Exception("Cannot marshal type FaqUnion");
        }

        public static readonly FaqUnionConverter Singleton = new FaqUnionConverter();
    }
}

// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using AnswersConverter;
//
//    var answers = Answers.FromJson(jsonString);

namespace AnswersConverter
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using J = Newtonsoft.Json.JsonPropertyAttribute;
    using R = Newtonsoft.Json.Required;
    using N = Newtonsoft.Json.NullValueHandling;

    public partial class AnswerClass
    {
        [J("answer")] public string Answer { get; set; }
    }

    public partial struct AnswerUnion
    {
        public List<AnswerClass> AnswerClassArray;
        public bool? Bool;

        public static implicit operator AnswerUnion(List<AnswerClass> AnswerClassArray) => new AnswerUnion { AnswerClassArray = AnswerClassArray };
        public static implicit operator AnswerUnion(bool Bool) => new AnswerUnion { Bool = Bool };
    }

    public class Answers
    {
        public static List<AnswerUnion> FromJson(string json) => JsonConvert.DeserializeObject<List<AnswerUnion>>(json, AnswersConverter.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this List<AnswerUnion> self) => JsonConvert.SerializeObject(self, AnswersConverter.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                AnswerUnionConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class AnswerUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AnswerUnion) || t == typeof(AnswerUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new AnswerUnion { Bool = boolValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<AnswerClass>>(reader);
                    return new AnswerUnion { AnswerClassArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type AnswerUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AnswerUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.AnswerClassArray != null)
            {
                serializer.Serialize(writer, value.AnswerClassArray);
                return;
            }
            throw new Exception("Cannot marshal type AnswerUnion");
        }

        public static readonly AnswerUnionConverter Singleton = new AnswerUnionConverter();
    }
}

// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using InsertChatMessageConverter;
//
//    var insertChatMessage = InsertChatMessage.FromJson(jsonString);

namespace InsertChatMessageConverter
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using J = Newtonsoft.Json.JsonPropertyAttribute;
    using R = Newtonsoft.Json.Required;
    using N = Newtonsoft.Json.NullValueHandling;

    public class InsertChatMessage
    {
        public static bool?[] FromJson(string json) => JsonConvert.DeserializeObject<bool?[]>(json, InsertChatMessageConverter.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this bool?[] self) => JsonConvert.SerializeObject(self, InsertChatMessageConverter.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }
}

// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using CommandsConverter;
//
//    var commands = Commands.FromJson(jsonString);

namespace CommandsConverter
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using J = Newtonsoft.Json.JsonPropertyAttribute;
    using R = Newtonsoft.Json.Required;
    using N = Newtonsoft.Json.NullValueHandling;

    public partial class CommandClass
    {
        [J("id")] public long Id { get; set; }
        [J("command")] public string Command { get; set; }
    }

    public partial struct CommandUnion
    {
        public bool? Bool;
        public CommandClass[] CommandClassArray;

        public static implicit operator CommandUnion(bool Bool) => new CommandUnion { Bool = Bool };
        public static implicit operator CommandUnion(CommandClass[] CommandClassArray) => new CommandUnion { CommandClassArray = CommandClassArray };
    }

    public class Commands
    {
        public static CommandUnion[] FromJson(string json) => JsonConvert.DeserializeObject<CommandUnion[]>(json, CommandsConverter.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this CommandUnion[] self) => JsonConvert.SerializeObject(self, CommandsConverter.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                CommandUnionConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class CommandUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CommandUnion) || t == typeof(CommandUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new CommandUnion { Bool = boolValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<CommandClass[]>(reader);
                    return new CommandUnion { CommandClassArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type CommandUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (CommandUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.CommandClassArray != null)
            {
                serializer.Serialize(writer, value.CommandClassArray);
                return;
            }
            throw new Exception("Cannot marshal type CommandUnion");
        }

        public static readonly CommandUnionConverter Singleton = new CommandUnionConverter();
    }
}

// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using ResponsesConverter;
//
//    var responses = Responses.FromJson(jsonString);

namespace ResponsesConverter
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using J = Newtonsoft.Json.JsonPropertyAttribute;
    using R = Newtonsoft.Json.Required;
    using N = Newtonsoft.Json.NullValueHandling;

    public partial class ResponseClass
    {
        [J("response")] public string Response { get; set; }
    }

    public partial struct ResponseUnion
    {
        public bool? Bool;
        public ResponseClass[] ResponseClassArray;

        public static implicit operator ResponseUnion(bool Bool) => new ResponseUnion { Bool = Bool };
        public static implicit operator ResponseUnion(ResponseClass[] ResponseClassArray) => new ResponseUnion { ResponseClassArray = ResponseClassArray };
    }

    public class Responses
    {
        public static ResponseUnion[] FromJson(string json) => JsonConvert.DeserializeObject<ResponseUnion[]>(json, ResponsesConverter.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this ResponseUnion[] self) => JsonConvert.SerializeObject(self, ResponsesConverter.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ResponseUnionConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ResponseUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ResponseUnion) || t == typeof(ResponseUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new ResponseUnion { Bool = boolValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<ResponseClass[]>(reader);
                    return new ResponseUnion { ResponseClassArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type ResponseUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ResponseUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.ResponseClassArray != null)
            {
                serializer.Serialize(writer, value.ResponseClassArray);
                return;
            }
            throw new Exception("Cannot marshal type ResponseUnion");
        }

        public static readonly ResponseUnionConverter Singleton = new ResponseUnionConverter();
    }
}

// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using AliasesConverter;
//
//    var aliases = Aliases.FromJson(jsonString);

namespace AliasesConverter
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using J = Newtonsoft.Json.JsonPropertyAttribute;
    using R = Newtonsoft.Json.Required;
    using N = Newtonsoft.Json.NullValueHandling;

    public partial class AliasClass
    {
        [J("alias")] public string Alias { get; set; }
    }

    public partial struct AliasUnion
    {
        public AliasClass[] AliasClassArray;
        public bool? Bool;

        public static implicit operator AliasUnion(AliasClass[] AliasClassArray) => new AliasUnion { AliasClassArray = AliasClassArray };
        public static implicit operator AliasUnion(bool Bool) => new AliasUnion { Bool = Bool };
    }

    public class Aliases
    {
        public static AliasUnion[] FromJson(string json) => JsonConvert.DeserializeObject<AliasUnion[]>(json, AliasesConverter.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this AliasUnion[] self) => JsonConvert.SerializeObject(self, AliasesConverter.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                AliasUnionConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class AliasUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AliasUnion) || t == typeof(AliasUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new AliasUnion { Bool = boolValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<AliasClass[]>(reader);
                    return new AliasUnion { AliasClassArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type AliasUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AliasUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.AliasClassArray != null)
            {
                serializer.Serialize(writer, value.AliasClassArray);
                return;
            }
            throw new Exception("Cannot marshal type AliasUnion");
        }

        public static readonly AliasUnionConverter Singleton = new AliasUnionConverter();
    }
}
